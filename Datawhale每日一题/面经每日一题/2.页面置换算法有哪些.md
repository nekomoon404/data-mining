# 页面置换算法

### 页面置换算法是用来做什么的？

虚拟内存技术，允许一个作业分多次调入内存；如果采用连续分配方式，会不方便实现；因此虚拟内存的实现需要建立在离散分配的内存管理方式基础上，虚拟内存的实现主要有：

1. 请求分页式存储管理；
2. 请求分段式存储管理；
3. 请求段页式存储管理

请求式的存储管理方式和传统的非连续分配存储管理方式的区别在于：

- 在程序执行过程中，当所访问的信息不在内存式，由操作系统负责将所需信息从外存调入内存，然后继续执行程序 —> 这就需要OS提供请求调页（或请求调段）功能；
- 若内存空间不足，由OS负责将内存中暂时用不到的信息换到外存 —> 这就需要OS提供 页面置换（或段置换）功能，**用页面置换算法决定应该换出哪个页面**

可见，**页面置换算法是用来在内存空间不足时，选择调出页面的算法**。页面的换入、换出需要磁盘I/O，会有较大的开销，因此**好的页面置换算法应该追求更少的缺页率。**

### 页面置换算法有哪些？

（一共五种，每种算法可以从淘汰页面的规则、实现方法、优缺点来展开说）

<img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20210510204622.png" style="zoom:67%;" />



- **最佳置换算法（OPT,  Optimal）**：

每次选择**淘汰的页面**将是**以后永不使用**，或者**在最长时间内不再被访问的页面**，这样可以**保证最低的缺页率。**

但实际上，只有在进程执行的过程中才能知道接下来会访问到的是哪个页面，操作系统无法提前预判页面访问序列。因此，**最佳置换算法是无法实现的**。

<img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20210510200707.png" style="zoom:67%;" />



- **先进先出置换算法（FIFO）：**

每次选择淘汰的页面是**最早进入内存的页面**。把调入内存的页面**按调入的先后顺序压入队列**，需要换出页面时选择队头页弹出即可，队列的最大长度取决于系统为进程分配了多少个内存块。

**FIFO算法会产生Belady异常**——当为进程分配的物理块数量增大时，缺页次数不减反增。FIFO算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问，因此FIFO算法性能较差。

<img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20210510200814.png" style="zoom:67%;" />

<img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20210510200913.png" style="zoom:67%;" />



- **最近最久未使用置换算法（LRU，least recently used）：**

每次淘汰的页面是**最近最久未使用的页面**；赋予每个页面对应的页表项，**用访问字段记录该页面自上次被访问以来所经历的时间t**，当需要淘汰一个页面时，**选择现有页面中t值最大的**，即最近最久未使用的页面。

LRU算法的实现需要专门的硬件支持，虽然算法性能好，但是实现困难，开销大。

<img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20210510201103.png" style="zoom:67%;" />



- **时钟置换算法**，又称**CLOCK算法**，或**最近未用算法（NRU，Not Recently Used）**：

为每个页面设置一个访问，**再将内存中的页面都通过指针链接成一个循环队列**。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位，如果是0，就选择该页换出；如果是1，则将其置为0，暂不换出，继续检查下一个页面。

若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0，再进行第二轮扫描，第二轮扫描中一定会有访问位为0的页面；因此，**简单的CLOCK算法选择一个淘汰页面最多会经过两轮扫描。**

<img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20210510202135.png" style="zoom: 80%;" />

<img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20210510202138.png" style="zoom:80%;" />

<img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20210510202241.png" style="zoom:80%;" />



- **改进型时钟置换算法**

如果被淘汰的页面没有被修改过，就不需要执行I/O 操作写回外存，只有被淘汰的页面被修改过时，才需要写回外存。

改造型时钟置换算法在简单的时钟置换算法的基础上，除了考虑一个页面最近有没有被访问过之外，**还考虑页面有没有被修改过**。**在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作**。

**改进型CLOCK置换算法选择一个淘汰页面最多会进行四轮扫描**。

<img src="https://gitee.com/nekomoon404/blog-img/raw/master/img/QQ图片20210510204432.png" style="zoom:67%;" />



> 参考：[3.2.3 OS之页面置换算法](https://blog.csdn.net/weixin_43914604/article/details/105997486)

